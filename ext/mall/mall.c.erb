#include <ruby.h>
#include <malloc.h>

/*
 * struct mallinfo {
 *	int arena;    // non-mmapped space allocated from system
 *	int ordblks;  // number of free chunks
 *	int smblks;   // number of fastbin blocks
 *	int hblks;    // number of mmapped regions
 *	int hblkhd;   // space in mmapped regions
 *	int usmblks;  // maximum total allocated space
 *	int fsmblks;  // space available in freed fastbin blocks
 *	int uordblks; // total allocated space
 *	int fordblks; // total free space
 *	int keepcost; // top-most, releasable (via malloc_trim) space
 * };
 */
<%
mallinfo_keys = %w(
arena
ordblks
smblks
hblks
hblkhd
usmblks
fsmblks
uordblks
fordblks
keepcost
) %>

<% mallinfo_keys.each { |x| %>
static VALUE sym_<%= x %>;
<% } %>

static VALUE info(VALUE klass)
{
	VALUE rv = rb_hash_new();
	struct mallinfo stats = mallinfo(); /* whee aggregate returns :( */

#define MALLINFO_SET(KEY) \
	rb_hash_aset(rv, sym_##KEY, INT2FIX(stats.KEY))

	MALLINFO_SET(arena);
	MALLINFO_SET(ordblks);
	MALLINFO_SET(smblks);
	MALLINFO_SET(hblks);
	MALLINFO_SET(hblkhd);
	MALLINFO_SET(usmblks);
	MALLINFO_SET(fsmblks);
	MALLINFO_SET(uordblks);
	MALLINFO_SET(fordblks);
	MALLINFO_SET(keepcost);

#undef MALLINFO_SET

	return rv;
}

/*
 * some malloc implementations may not like mallopt() being called after
 * malloc has been initialized (first call to malloc()).  This is not
 * the case with glibc malloc.
 */
static VALUE opt(VALUE klass, VALUE param, VALUE value)
{
	int rv = mallopt(FIX2INT(param), FIX2INT(value));

	return rv == 0 ? Qfalse : Qtrue;
}

#ifdef HAVE_MALLOC_TRIM
static VALUE trim(VALUE klass, VALUE pad)
{
	unsigned long tmp = NUM2ULONG(pad);
	int rv = malloc_trim((size_t)tmp);

	return rv == 1 ? Qtrue : Qfalse;
	return Qfalse;
}
#endif /* HAVE_MALLOC_TRIM */

#ifdef HAVE_MALLOC_STATS
static VALUE dump_stats(VALUE klass)
{
	malloc_stats();
	return Qnil;
}
#endif /* HAVE_MALLOC_STATS */

#ifdef HAVE_MALLOC_INFO
static ID id_ltlt;
#include <stdio.h>
#include <errno.h>
static void xmlerr(FILE *fp, int err, const char *msg)
{
	fclose(fp);
	errno = err ? err : EIO; /* gotta have something */
	rb_sys_fail(msg);
}

static VALUE xml(int argc, VALUE *argv, VALUE self)
{
	int err;
	long len;
	VALUE options, out, buf;
	int xoptions;
	FILE *fp;

	rb_scan_args(argc, argv, "02", &options, &out);
	xoptions = NIL_P(options) ? 0 : NUM2INT(options);

	fp = tmpfile();
	if (fp == NULL)
		rb_sys_fail("tmpfile");

	err = malloc_info(xoptions, fp);
	if (err != 0)
		xmlerr(fp, err, "malloc_info");

	len = ftell(fp);
	if (len < 0)
		xmlerr(fp, errno, "ftell");

	rewind(fp);
	buf = rb_str_new(0, len);
	if (fread(RSTRING_PTR(buf), 1, len, fp) != len)
		xmlerr(fp, ferror(fp), "fread");
	fclose(fp);

	if (NIL_P(out))
		return buf;
	return rb_funcall(out, id_ltlt, 1, buf);
}
#endif /* HAVE_MALLOC_INFO */

void Init_mall(void)
{
	VALUE mMall = rb_define_module("Mall");
	rb_define_singleton_method(mMall, "opt", opt, 2);
	rb_define_singleton_method(mMall, "info", info, 0);
#ifdef HAVE_MALLOC_TRIM
	rb_define_singleton_method(mMall, "trim", trim, 1);
#endif /* HAVE_MALLOC_TRIM */
#ifdef HAVE_MALLOC_STATS
	rb_define_singleton_method(mMall, "dump_stats", dump_stats, 0);
#endif /* HAVE_MALLOC_STATS */
#ifdef HAVE_MALLOC_INFO
	id_ltlt = rb_intern("<<");
	rb_define_singleton_method(mMall, "xml", xml, -1);
#endif /* HAVE_MALLOC_INFO*/

<% mallinfo_keys.each { |x| %>
	sym_<%= x %> = ID2SYM(rb_intern("<%= x %>"));
<% } %>

<% %w(
mxfast nlblks grain keep
trim_threshold top_pad mmap_threshold mmap_max
check_action perturb
).each { |opt|
  opt.upcase!
  m_opt = "M_#{opt}"
%>
#ifdef <%= m_opt %>
        rb_define_const(mMall, "<%= opt %>", INT2FIX(<%= m_opt %>));
#endif /* <%= m_opt %> */
<% } %>
}
